  # 数据库

1. **数据库事务特性**

   ACID：**原子性**（Atomicity）、**一致性**（Consistency）、**隔离**性（Isolation）、**持久性**（Durability）。

   原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

   一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。在一致性下，所有事务对一个数据的读取结果都是相同的。

   隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

   持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

2. **隔离性级别**

   脏读：指一个事务处理过程中读取了另一个未提交事务中的数据。

   不可重复读：指对于数据库中某个数据，一个事务范围内多次查询却返回了不同值（查询间隔期间被其它事务更改）。

   幻读：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

   幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

   MySQL数据库为我们提供的**四种隔离级别**：

   ① Serializable (**串行化**)：可避免脏读、不可重复读、幻读的发生。

   ② Repeatable read (**可重复读**)：可避免脏读、不可重复读的发生。

   ③ Read committed (**读已提交**)：可避免脏读的发生。

   ④ Read uncommitted (**读未提交**)：最低级别，任何情况都无法保证。

   以上四种隔离级别最高的是Serializable级别，最低的是Read  uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式，使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。
   
3. **数据库三大范式？**

   * 第一范式：每个列都不可以再拆分
   * 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能依赖于主键的一部分
   * 第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其它非主键

4. **mysql数据类型？**

   * 整数类型：`TINYINT`，`SMALLINT`，`MEDIUMINT`，`INT`，`BIGINT`，分别是1、2、3、4、8字节。任何整数类型都可以家上`UNSIGNED`属性，表示无符号整数。整数类型可以被指定长度，例如`INT(11)`表示长度为11的INT整型。
   * 实数类型：包括`FLOAT`，`DOUBLE`，`DECIMAL`。`DECIMAL`可以用于存储比`BIGINT`还要大的整型，能存储精确的小数。而`FLOAT`和`DOUBLE`是有取值范围的。计算时，`FLOAT`,`DOUBLE`效率要高一些。
   * 字符串类型：`VARCHAR`，`CHAR`，`TEXT`，`BLOBVARCHAR`用于存储可变长度字符串，它比定长类型更节省空间。`VARCHAR`使用额外的1或2字节存储字符串长度，存储的内容超过设置的长度时，内容被会截断。`CHAR`定长的，根据定义的字符串长度分配足够的空间。`CHAR`会根据需要使用空格进行填充方便比较。`CHAR`适合存储很短的字符串，或者所有值都接近同一个长度。`CHAR`存储的内容超过设置的长度时，会被截断。
   * 枚举类型：把不重复的数据存储为一个预定义的集合，有时可以使用`ENUM`代替常用的字符串类型。`ENUM`存储非常紧凑，会把列表值压缩到一个或两个字节。`ENUM`在内部存储时，其实存的是整数。
   * 日期和时间类型：尽量使用`timestamp`，空间效率高于`datetime`，用整数保存时间戳通常不方便处理。如果需要存储微秒，可以使用`bigint`存储。

5. **什么是索引？**

   * 索引是一种特殊的文件，它们包含这对数据表里所有记录的引用指针。
   * 索引是一种数据结构，数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据。索引的实现通常是B树或B+树。
   * 更通俗的说，索引就相当于目录，为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

6. **索引有那几种类型？**

   * 主键索引：数据列不允许重复，不允许为NULL，一个表只能有一个主键
   * 唯一索引：数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引
   * 普通索引：基本的索引类型，没有唯一性限制，允许为NULL值
   * 全文索引：是目前搜索引擎使用的一种关键技术

7. **索引的数据结构？**

   * B树、B+树、哈希

8. **索引设计的原则？**

   * 适合索引的列是出现在where子句中的列，或者连接子句中指定的列。
   * 基数较小的类，索引效果较差，没有必要在此列建立索引。
   * 使用短索引，如果对长字符串进行索引，应该指定一个前缀长度，这样能够节省大量空间
   * 不要过度索引，索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只需保持需要的索引有利于查询即可。

9.  **使用索引查询一定能提高查询的性能吗？**

   通常，通过索引查询数据比全表扫描要快，但是也必须注意它的代价。索引需要额外的空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也被修改，这意味着每条记录的INSERT、DELETE、UPDATE的将为此多付出几次的磁盘IO。因为索引需要额外存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能。

10. **B树和B+树的区别？**

    * 在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。
    * B树可以在内部节点同时存放键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。
    * 由于B+树内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快的缩小查找范围。B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树这需要对树的每一层进行遍历，会需要更多的内存置换次数，因此也就需要花费更多的时间。

11. **数据库的乐观锁和悲观锁是什么，怎么实现？**

    数据库管理系统中的并发控制的任务是确保在多个事务同时存取数据库中的同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制和悲观并发控制时并发控制主要采用的手段。

    * 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。
    * 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违法数据完整性。在修改数据的时候把事务锁起来，通过version的方式进行锁定。实现方式：乐观锁一般使用版本号机制或CAS算法实现。

12. **MyISAM和InnoDB的区别？**

    * InnoDB支持事务，MyISAM不支持事务，这也是MySQL选择InnoDB作为默认存储引擎的原因之一
    
    * InnoDB支持外键，MyISAM不支持，如果一个表包含外键，并且存储引擎是InnoDB，把它转为MyISAM会失败

    * InnoDB使用的是聚集索引，MyISAM使用非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，所以InnoDB必须有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查到主键，然后通过主键查到数据。所以，主键不应该过大，因为主键过大，其它索引也会很大。非聚集索引的花，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引都是独立的。

    * InnoDB不保存表的具体行数，执行`select count(*) from table`时需要全表扫描。但是MyISAM用一个变量保存了整个表的行数，执行上述语句只需要读出该变量即可，速度很快。

    * InnoDB最小的锁粒度时行级锁，MyISAM最小的锁粒度是表级锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，所以并发访问受到很大限制。