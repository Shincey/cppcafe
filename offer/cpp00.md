# C++

1. **C++ 中析构函数可以为纯虚函数吗？**

   可以为纯虚函数，如果基类将析构函数设置为纯虚函数，那么基类就会成为抽象类，是不能创建对象的。且如果基类不提供纯虚析构函数的定义的话，使用基类指针指向派生类对象会出现无法解析的外部符号命令错误，所以基类同时也必须提供纯虚析构函数的定义。

2. **实现`#define max(a, b, c)`**

   ```c++
   #define max(a, b, c) (a > b ? (a > c ? a : c) : (b > c ? b : c))
   ```

3. **C++ 中引用和指针的区别？**
   * 引用是别名，在函数内操作一个通过传引用方式传入的变量，相当于直接操作函数外原本的变量。指针是一个变量，但是不同于一般变量，指针存放的是内存地址。传指针方式传入函数内的指针，只是拷贝外部指针的副本，可以在函数内修改它们共同指向的内存区域，但是却无法在函数内修改函数外指针本身。
   * 声明方式不同，一个通过`&`，一个通过`*`。
   * 引用一旦绑定不可更改，指针可以更改指向地址。
   * 引用是和绑定变量共享内存的，并不另外为引用开辟一块内存。指针是一个独立的变量，需要占据内存，且可改变它存储的内容。
   * 引用不可以绑定到`null`值，指针可以直接指向`null`值。
   * 不可以创建引用数组，可以创建指针数组。~~`int & a[];`~~

4. **std::unordered_map/std::map的区别?**
   * `unordered_map`内部采用哈希表实现，所有元素是无序的，`map`内部采用自平衡BST类似红黑树实现，除内置类型外，自定义类型在插入时需要重载比较`<`运算符帮助每次插入元素时进行比较，所以`map`中的元素是有序的。
   * `unorder_map`查询、插入和删除时间平均是O(1)，最坏的情况是O(n)，`map`查询log(n)，插入和删除是log(n)+恢复平衡的花销。

5. **介绍一下vector，及如何扩容**

   `vector`是STL中实现的一个容器，类似数组，会开辟一块线性连续的内存，与`array`不同，其对于空间的运用更灵活（`array`静态空间，一旦数据满了可能得程序员手动去执行：配置新空间->数据移动->释放旧空间）。`vector`一旦就空间装满，就会自动扩充空间（不论多大，当然不太可能每新增一个元素就去扩展空间）。

   为了降低空间配置的速度成本，`vector`实际配置的大小比用户分配的大小要更大一些，以备扩充使用，即容量的概念。`vector`会以`start`、`finish`两个迭代器来分别指向连续内存中目前已被使用的范围，以`end_of_storage`指向整块连续空间（含备用空间）的尾端。

   当我们以`push_back`将新元素插入尾端时，该函数首先检测是否还有备用空间，如果有直接在备用空间上构造元素，并调整`finish`，如果没有空间，就扩充空间（分配空间->移动数据->释放原空间）。动态增加大小并不是在原空间之后接着新空间，因为无法保证原空间之后还有足够空闲的空间可供使用，而是以原大小两倍在另外地址开辟一块新空间，然后拷贝原内容。对`vector`的任何操作，一旦引起空间重新配置，指向原`vector`的所有迭代器就都失效了，务必小心。
   
   > 参考《STL源码剖析》

   <div style="text-align:center"><img src="https://i.loli.net/2020/06/30/V49nq5xyg3WrZTM.jpg" alt="image.png" style="zoom: 25%;" /></div>

6. **什么情况下出现野指针**

   ```c++
   int *ptr = new int;
   //... use ptr to do something
   delete ptr;
   // ptr = nullptr;
   
   // 在释放了 ptr 指向的内存之后，没有给ptr指向新的内存，又继续使用了 ptr，所以最好释放之后指向 nullptr
   *ptr = 3;
   
   // 指向了 nullptr 之后，在使用 ptr 时可以增加一个判断，提升程序鲁棒性
   if (ptr) *ptr = 3;
   ```

7. **new和malloc区别**

   * 二者都是在堆上动态开辟内存，返回指向新内存的指针。`new`返回指定类型指针，而`malloc`返回`void *`，需要自己强制转化

   * `new`是操作符，`malloc`是库函数
   * 释放内存方式不一样`delete`、`free`
   * `malloc`只是开辟一块内存，并不做任何初始化，`new`会调用相应的构造函数完成初始化

8. **static_cast、dynamic_cast、const_cast、reinterpret_cast、bad_cast**

   * `static_cast`：用于非多态类型的转换、不执行运行时类型检查、通常用于数值类型转换、在类结构层次中，子类转父类（向上）安全，父类转子类不安全（子类可能存在不在父类的字段或方法）
   * `dynamic_cast`：用于多态类型转换、执行运行时类型检查、只适用于指针或引用、对不明确的指针将转换失败（返回`nullptr`），但不引发异常、可以在整个类结构层次移动指针，包括向上和向下
   * `const_cast`：用于删除`const`、`volatile`、`__unaligned`特性（如将`const int`转化为`int`）
   * `reinterpret_cast`：用于位的简单重新解释、滥用`reinterpret_cast`可能很容易带来风险，除非所需转化本身是低级别的，否则应使用其他强制转化运算符、允许将任何指针转化为任何其他指针类型、也允许将任何整数类型转换为任何指针类型以及反向转换、不能丢掉`const`、`volatile`、`__unaligned`特性、一个实际用途是在哈希函数中，通过让两个不同的值几乎不宜相同的索引结尾的方式将值映射到索引
   * `bad_cast`：由于强制转化为应用类型失败，`dynamic_cast`运算符引发`bad_cast`异常：
      ```c++
      try {
         A& ref = dynamic_cast<A&>(var);
      }
      catch (bad_cast e) {
         cout << b.what() << endl;
      }
      ```

   
