# 操作系统

1. **什么是守护进程、以及如何创建守护进程**

   守护进程（daemon进程）是一个长时间运行并且没有控制终端的进程（即它运行在后台）。守护进程与后台进程还是有区别的：守护进程完全脱离终端，而后台程序未完全脱离终端。守护进程在关闭终端时不受影响，而后台程序一般随用户退出而停止（以`nohup command &`格式运行可以避免）。守护进程的会话组、当前目录、文件描述符都是独立的，后台程序知识终端进行了一次`fork`，让程序在后台运行，这些都没改变。

   一般的网络服务都是以守护进程的方式运行。守护进程的名字通常以`d`结尾（不是标准）。

   创建一个守护进程的过程：

   1）执行一个`fork`，之后父进程退出，子进程在后台继续执行（结果是`daemon`成了init进程的子进程）。

   2）子进程调用`setsid()`开启一个新的会话，并释放它与控制终端之间的所有关联。（调用`setsid`会使子进程成为新的会话组首领和新的进程组首领，并失去控制终端）

   3）避免`daemon`重新打开一个终端设备：在所有可能应用到一个终端设备上的`open()`调用中指定`O_NOCTTY`标记。或者简单说，在`setsid()`调用后执行第二个`fork()`，让子进程退出，让孙子进程继续执行。这样就确保孙子进程不会成为会话组领导，根据System V中获取终端的规则（Linux也遵循），进程将永远不会重新请求一个控制终端。

   4）清除进程`umask`，以确保daemon创建文件和目录时拥有所需的权限。

   5）更改当前工作目录为根目录（`/`）。因为daemon通常运行到系统关闭，如果其当前目录不包含`/`的文件系统，那么就无法卸载该文件系统。

   6）关闭从父进程继承来的所有打开着的文件描述符。由于daemon失去了控制终端并且在后台运行，因此让daemon保持文件描述符0、1、2的打开状态没有意义，因为它们就是指向控制终端。可以重定向到`/dev/null`上。（`/dev/null`是一个虚拟设备，它总会将写入的数据丢弃，当成无底洞即可）（避免调用的一些库函数会向标准输出上输出一些信息）（文件描述符是一种有限的资源）

   7）用`openlog`函数建立与`syslogd`的连接。（daemon在后台运行，没法像普通程序将消息输出到关联的终端，所以可以将消息写入到一个特定于应用程序的日志文件中）

   daemon应该在合适的地方正确的处理`SIGTERM`和`SIGHUP`信号，`SIGTERM`信号的处理方式应该是按序关闭这个daemon，而`SIGHUP`信号则提供了一种机制让daemon通过读取配置文件并重新打开所使用的日志文件来重新初始化自身。

   > 参考：《Linux/Unix系统编程手册》第37章

2. **用户态、内核态**

   Linux操作系统的体系架构分为用户态和内核态（用户空间和内核），内核本质上是一种软件，控制着计算机硬件资源，并为上层应用程序提供运行环境。用户态即上层应用的活动空间，通过访问内核提供的接口：系统调用，来访问内核控制的资源。系统调用是操作系统的最小功能单元，linux提供了很多系统调用。而库函数则是对这些系统调用的封装，让程序员可以从复杂的细节中解脱。

   用户态切换到内核态的三种情况：a. 系统调用。b. 异常事件（如缺页）。c. 外围设备中断。系统调用本质也是中断，相对于外围设备的硬中断，其称为软中断。三种切换方式相同，都是执行了一个中断响应过程。只有系统调用是主动请求切换，其余则是被动。